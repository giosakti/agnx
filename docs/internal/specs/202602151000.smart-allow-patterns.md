# Smart Allow Patterns for "Allow Always"

**Status:** Draft

## Problem

When a user clicks "Allow Always" on a command like:
```
cd /home/user/.duragent/agents/my-agent/artifacts/my-project && git add -A && git commit -m "Add scenario selection, API key validation"
```

The system saves the **exact command** as the allow pattern:
```yaml
allow:
  - "bash:cd /home/user/.duragent/agents/my-agent/artifacts/my-project && git add -A && git commit -m \"Add scenario selection, API key validation\""
```

This pattern never matches again because the next commit will have a different message. The user intended "always allow git commits in this project" but got "allow this exact command verbatim."

## Security Constraint

Naive globbing is dangerous. If we save `bash:cd /path && git*`, then the LLM could later generate:
```
cd /path && git commit -m "msg"; rm -rf /
```
...and it would match, because `*` swallows everything including the `; rm -rf /` suffix.

The core issue: **compound commands can hide dangerous sub-commands after the approved prefix.**

## Design

### Approach: Per-Segment Pattern Matching

Instead of matching the entire compound command as one string, split it into segments and check each independently.

**When saving (allow_always):**
1. Split the command on `&&`, `||`, `;`, `|`
2. For each segment, extract the **command prefix** (first 1-2 words) and append `*`
3. Save each segment as a separate allow pattern

**When checking (policy check for bash):**
1. Split the candidate command on the same separators
2. **Every** segment must match at least one allow pattern
3. If any segment has no matching allow pattern, the compound command is not allowed

### Example

User approves: `cd /opt/.../liege && git add -A && git commit -m "long message"`

Saved patterns:
```yaml
allow:
  - "bash:cd /home/user/.duragent/agents/my-agent/artifacts/my-project"
  - "bash:git add *"
  - "bash:git commit *"
```

Next time, agent runs: `cd /opt/.../liege && git add -A && git commit -m "different message"`
- Segment 1: `cd /opt/.../liege` → matches `bash:cd /opt/.../liege` ✓
- Segment 2: `git add -A` → matches `bash:git add *` ✓
- Segment 3: `git commit -m "different message"` → matches `bash:git commit *` ✓
- **Result: allowed** ✓

Attack: `cd /opt/.../liege && git add -A && git commit -m "msg"; rm -rf /`
- Segment 1: `cd /opt/.../liege` → matches ✓
- Segment 2: `git add -A` → matches ✓
- Segment 3: `git commit -m "msg"` → matches ✓
- Segment 4: `rm -rf /` → **no matching pattern** ✗
- **Result: requires approval** ✓

### Segment Splitting

Split on these shell operators (respecting quoting):
- `&&` — AND
- `||` — OR
- `;` — sequential
- `|` — pipe

Each segment is trimmed of whitespace.

Quoted strings are respected: `echo "hello && world"` is one segment, not two.

### Pattern Generation Per Segment

For each segment, determine how much to keep literal vs glob:

| Segment | Generated Pattern | Rationale |
|---------|------------------|-----------|
| `cd /exact/path` | `cd /exact/path` | cd is always to a specific directory — keep exact |
| `git add -A` | `git add *` | git subcommand is meaningful, args vary |
| `git commit -m "msg"` | `git commit *` | git subcommand is meaningful, message always varies |
| `npm install pkg` | `npm install *` | npm subcommand matters, package varies |
| `cargo build` | `cargo build *` | cargo subcommand matters |
| `echo "hello"` | `echo *` | command name matters, args vary |
| `cat file.txt` | `cat *` | command name matters, file varies |

**Rule:** Keep the first word (the command). For known multi-word commands (`git <sub>`, `cargo <sub>`, `docker <sub>`, `npm <sub>`, `kubectl <sub>`), keep the first two words. Append `*` for the rest.

**Exception:** `cd` keeps the full path (no glob) — the directory is the meaningful part, and globbing `cd *` would allow cd anywhere.

### Changes Required

#### 1. New function: `generate_allow_pattern` (`agent/policy.rs`)

```
fn generate_allow_pattern(tool_type: ToolType, command: &str) -> Vec<String>
```

- For non-bash tools: return single pattern `tool_type:command` (current behavior)
- For bash: split into segments, generate pattern per segment, return multiple patterns

#### 2. Update `add_pattern_and_save` (`agent/policy.rs`)

Change to call `generate_allow_pattern` and add all resulting patterns.

#### 3. New function: `check_compound_bash` (`agent/policy.rs`)

```
fn check_compound_bash(policy: &ToolPolicy, command: &str) -> PolicyDecision
```

- Split command into segments
- Check each segment against allow/deny lists independently
- If ANY segment is denied → Deny
- If ALL segments are allowed → Allow
- Otherwise → Ask (or Deny in restrict mode)

#### 4. Update `ToolPolicy::check`

For bash commands, delegate to `check_compound_bash` instead of checking the whole string.

### Edge Cases

- **Single commands (no separators):** One segment, works like today but with smarter globbing
- **Nested quoting:** `echo "hello && world"` — the `&&` inside quotes is not a separator
- **Subshells:** `$(command)` and backticks — treat as opaque, don't split inside them
- **Heredocs:** Rare in agent context, treat as single segment

### Quote-Aware Splitting

A simple state machine that tracks:
- Inside single quotes `'...'`
- Inside double quotes `"..."`
- Inside `$(...)` (nesting depth)

Only split on `&&`, `||`, `;`, `|` when not inside any of these.

## Non-Goals

- Full shell parsing (bash grammar is complex). A best-effort split that handles common cases is sufficient.
- Changing deny list behavior. Deny patterns still match the whole command string — they're a safety net and shouldn't be weakened.
- Automatic pattern suggestions in UI. The pattern is generated and saved silently, same as today.

## Migration

Existing exact-match patterns in `policy.local.yaml` continue to work — they just match as before (exact substring). New "allow_always" clicks produce the smarter segmented patterns. No migration needed.
