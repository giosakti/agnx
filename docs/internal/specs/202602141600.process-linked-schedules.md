# Process-Linked Schedules

## What is this?

An optional `process_handle` field on schedules that auto-cancels the schedule when the linked background process exits. Eliminates redundant poll cycles and prevents coordination bugs between the watch-schedule and completion callback.

## The Problem

The [watch pattern](../../book/src/guides/background-processes.md) composes `background_process` + `schedule` for process supervision. It works today but has a coordination gap:

1. Agent spawns a process, creates a recurring schedule to poll it
2. Process exits → `fire_completion_callback` fires
3. The watch-schedule keeps firing after the process is done
4. The schedule's task eventually notices the process is terminal and cancels itself — but only on the next poll

This wastes at minimum one LLM call per watch-schedule after the process exits. More importantly, the completion callback and a stale watch-poll can race, producing duplicate or confusing messages in the session.

## User Scenario

1. User: "Run Claude Code to refactor auth, check on it every 30 seconds"
2. Agent spawns process → gets handle `proc-abc123`
3. Agent creates schedule: `every_seconds: 30`, `task: "Check process proc-abc123..."`, `process_handle: "proc-abc123"`
4. Every 30s the schedule fires and the agent inspects/interacts with the process
5. Process exits → `fire_completion_callback` auto-cancels the linked schedule **before** firing the callback
6. No stale poll, no duplicate messages

## Design

### New field on `Schedule`

```rust
pub struct Schedule {
    // ... existing fields ...

    /// Optional process handle. When set, the schedule is automatically
    /// cancelled when the linked process reaches a terminal state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub process_handle: Option<String>,
}
```

### New field on schedule tool args

```json
{
  "action": "create",
  "every_seconds": 30,
  "task": "Check process proc-abc123 ...",
  "process_handle": "proc-abc123"
}
```

The `process_handle` is optional. When omitted, the schedule behaves exactly as it does today.

### Auto-cancel in `fire_completion_callback`

In `process/registry.rs`, `fire_completion_callback` already runs when a process reaches a terminal state. Add one step before the existing callback logic:

```
fire_completion_callback(handle_id):
  1. [NEW] Ask scheduler to cancel all schedules linked to this handle
  2. [EXISTING] Read log tail, build completion message, run callback
```

This requires the `ProcessRegistryHandle` to have access to `SchedulerHandle`. It already has access to `RuntimeServices` — the scheduler handle can be accessed the same way.

### Scheduler: cancel by process handle

Add a new method on `SchedulerHandle`:

```rust
pub async fn cancel_by_process_handle(&self, process_handle: &str, agent: &str)
```

This iterates active schedules for the agent, finds any with a matching `process_handle`, and cancels them. It's a scan, not a lookup — acceptable because the number of active schedules per agent is small (typically < 10).

### Validation

When `process_handle` is provided on schedule creation:
- The process handle is stored as-is (no validation that it exists). The process may have been spawned in a different session or may not exist yet in edge cases.
- If the process is already terminal at schedule creation time, the schedule is still created — it will be cancelled on the next check. This avoids a TOCTOU race.

### Persistence

The `process_handle` field is serialized to the schedule YAML file:

```yaml
id: sched_01ABC
agent: my-assistant
process_handle: proc-abc123    # new field
destination:
  gateway: telegram
  chat_id: "123456789"
schedule:
  every:
    every_seconds: 30
payload:
  task:
    task: "Check process proc-abc123..."
```

Existing schedules without `process_handle` deserialize with `None` (backwards compatible via `#[serde(default)]`).

## Implementation

### Files to change

1. **`scheduler/schedule.rs`** — Add `process_handle: Option<String>` to `Schedule`
2. **`scheduler/service.rs`** — Add `cancel_by_process_handle()` method
3. **`process/registry.rs`** — Call `cancel_by_process_handle()` at start of `fire_completion_callback`
4. **`process/mod.rs`** — Add `SchedulerHandle` to `ProcessRegistryHandle` (or access via `RuntimeServices`)
5. **`tools/builtins/schedule.rs`** — Pass through `process_handle` from args to `Schedule`
6. **`server.rs`** — Wire scheduler handle into process registry construction (if not already accessible)

### Tests

- Unit: `Schedule` with `process_handle` serializes/deserializes correctly
- Unit: `cancel_by_process_handle` cancels matching schedules, ignores non-matching
- Unit: schedule tool parses `process_handle` argument
- Integration: spawn process + create linked schedule + process exits → schedule auto-cancelled

## Acceptance Criteria

- [ ] `schedule create` accepts optional `process_handle` parameter
- [ ] `process_handle` persists in schedule YAML and survives restart
- [ ] When a process reaches terminal state, all linked schedules are cancelled before the completion callback fires
- [ ] Schedules without `process_handle` are unaffected (no behavior change)
- [ ] `schedule list` shows `process_handle` when present

## Out of Scope

- Bidirectional linking (process knowing about its schedules)
- Automatic schedule creation on spawn (agent still creates both explicitly)
- Validation that the process handle exists at schedule creation time
